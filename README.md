# Семинары ЗБ-ПИ20-1/ЗБ-ПИ20-2
____


## Распределение баллов за работу в семестре:
- [Расчетно-аналитическая работа](#расчетно-аналитическая-работа) - 20 баллов
- [Работа на семинарах](#работа-на-семинарах) - 20 баллов
- [Экзамен](#пример-экзаменационного-билета) - 60 баллов
_________

## Расчетно-аналитическая работа (РАР).

Тема РАР "Разработка и реализация высокопроизводительного параллельного алгоритма решения задачи ..."

Конкретизация темы РАР выбирается студентом из предложенного [списка](#список-рар), допускается инициатива студента по авторской конкретизации темы РАР, окончательная версия названия темы утверждается преподавателем.

Утверждение темы происходит в начале семестра.

По итогам работы студент сдает разработанную самостоятельно программу, подпрограмму или библиотеку подпрограмм, направленную на решение выбранной задачи с помощью методов высокопроизводительных вычислений.

Допускается использование любого языка программирования и любой среды параллельного программирования по желанию студента. Примеры возможных наборов инструментов для решения задачи:

С/С++ + OpenMP
C/C++ + MPI
Python + multiprocessing
Node.js + worker_threads
Java + Fork/Join

Рекомендуется выкладывать на github, чтобы получать обратную связь от преподавателя через issue.
Однако, для официальной отчётности РАР предоставляется в виде текстового файла docx или odt. Форма представления - загрузка файла на campus.fa.ru

Срок предоставления работы - 13 мая 2024 года.

Письменная работа оценивается в 20 баллов (максимум).
## Список РАР
1. Вершинное покрытие. Дано множество городов С и дорог между ними. Определить,
существует ли такое подмножество С, включающее не более K городов, что для любой
существующей дороги город из этого подмножества является либо ее началом, либо концом.
2. Путь с запрещенными парами. Дано множество городов и односторонних дорог между
ними, а также набор взаимоисключающих пар городов. Известны начальный и конечный
города. Определить, существует ли путь из начального города в конечный, не проходящий
одновременно через оба города из каждый запрещенной пары.
3. Максимальный разрез. Дано множество городов, дорог между ними, и известны длины
для каждой дороги. Определить, можно ли это множество городов разбить на два
непересекающихся подмножества так, чтобы сумма расстояний по прямым дорогам от
городов одного подмножества до городов другого не превышала K.
4. Надежность сети. Дана сеть, ее подсеть, вероятности неисправности при проходе по
каждому из ребер и надежность сети q. Узнать, верно ли, что для любых двух узлов подсети
между ними существует путь с надежностью не меньшей чем q.
5. Выживаемость сети. Дана сеть, вероятности неисправности для каждого узла и каждого
ребра, надежность сети q. Узнать, верно ли, что для любого ребра сети вероятность
неисправности этого ребра или одного из узлов, соединяемых им, не меньше q.
6. Задача коммивояжера. Дано множество городов и расстояний между ними, требуемая
минимальная длина пути. Определить, существует ли замкнутый путь, включающий в себя
все города, такой, что его длина не больше чем требуемая минимальная длина пути.
7. Китайский почтальон. Дано множество городов и дорог между ними, при этом
некоторые дороги одностороние. Для каждой дороги известна ее длина. Определить,
существует ли замкнутый путь, включающий в себя все города и имеющий длину не
большую K.
8. Сельский почтальон. Дано множество городов и множество дорог между ними, причем
часть дорог проходит по сельской местности. Для каждой дороги известна ее длина.
Определить, существует ли замкнутый путь, включающий в себя все города, имеющий длину
не большую K и проходящий через все сельские дороги.
9. Трехмерное сочетание. Дано множество кортежей (w, x, y), где w, x, y – числа от 1 до N.
Определить, верно ли, что в исходном множестве существует такое подмножество, что
количество элементов в нем равно N и у любых двух элементов все соответствующие
значения w, x и y различны.
10. Упаковка множеств. Дан набор конечных множеств и положительное целое число K.
Определить, верно ли, что в этом наборе содержится не менее K непересекающихся
множеств.
11. Разбиение множества. Дано некоторое количество предметов и веса каждого из них.
Определить, можно ли сгруппировать эти предметы в две группы так, чтобы вес обеих групп
был одинаков.
12. Упаковка в контейнеры. Дано некоторое количество предметов и веса каждого из них.
Определить, можно ли сгруппировать эти предметы не более чем в K групп так, чтобы
суммарный вес каждой группы не превышал B.
13. Динамическое распределение памяти. Дан набор структур данных, для каждой из
которых известны размер в байтах, время поступления и время обработки (время, в течение
которого структура должна находиться в памяти). Определить, можно ли для хранения и
обработки этих данных использовать область памяти размером B байт.
14. Хранение данных в сети с дублированием. Дана сеть, для каждого узла которой
известно количество обращений и стоимость хранения данных. Определить, можно ли
выделить такую подсеть, что сумма стоимостей хранения во всех ее узлах, сложенная с
суммой произведений расстояний от каждого узла исходной сети до подсети (количество
переходов по ребрам до ближайшего узла подсети) на число обращений к узлу исходной сети
не превышает K.
15. Кратчайшая общая надпоследовательность. Дано множество слов (необязательно
существующих), состоящих из букв русского языка. Определить, существует ли такое слово
(необязательно существующее), состоящее из букв русского языка, что его длина не больше
K и любое слово из исходного множества слов является его подпоследовательностью.
16 Прямоугольное сжатие изображения. Дано монохромное изображение: матрица NxM,
содержащее только нули и единицы. Определить, можно ли покрыть все единичные
элементы изображения не более чем K прямоугольниками.
17. Многопроцессорное расписание. Дано множество процессов и времена выполнения
каждого из них (число процессорных инструкций). Также дано множество процессоров и
скорость каждого из них (инструкций в секунду). Определить, можно ли так распределить
процессы между процессорами, что общее время выполнения не будет превышать D секунд.
18. Многопроцессорное расписание с предшествованием. Дано множество процессов,
каждый из которых состоит из N процессорных команд и множество процессоров, скорость
каждого из которых известна (в командах в секунду). Известно, что определенные процессы
должны быть выполнены раньше других. Определить, можно ли так распределить процессы
между процессорами, что общее время выполнения не будет превышать D секунд.
19. Многопроцессорное расписание в системе реального времени. Дано множество
процессов, каждый из которых состоит из N процессорных команд и множество процессоров,
скорость каждого из которых известна (в командах в секунду). Для каждого процесса
известно время, до которого он должен выполниться. Определить, можно ли так
распределить процессы между процессорами, что все ограничения будут выполнены.
20. Конвейерное многопроцессорное расписание. Дано множество процессов, каждый из
которых состоит из N процессорных команд и N процессоров, причем i-я команда может
выполняться только i-ым процессором, а ее выполнение отнимает заданное для каждого
процессора время. Определить, можно ли так распределить процессы между процессорами,
что общее время выполнения не будет превышать D секунд.
21. Генерация кода для параллельных присваиваний. Дано N переменных и N операторов
присваиваний, в правой части которых могут стоять любые операции с переменными из
списка заданных (наборы этих переменных для каждого присваивания также известны).
Определить, можно ли так упорядочить операторы присваивания, что будет иметься не более
K значений i таких, что для i-го оператора присваивания переменная, стоящая в левой его части, входит в правую часть одного из последующих присваиваний.
22. Оптимизация микрокода. Дано множество микрокоманд и набор микроинструкций,
каждая из которых состоит из некоторого количества микрокоманд. Определить, можно ли
для данного набора микроинструкций использовать K-битовый формат

# Практические работы ЗБ-ПИ20-1 ЗБ-ПИ20-2


## OpenMP

*семинары 1.06.2024*

Задачи для самостоятельного решения к 2.1–2.4
1. Выполнить сложение двух векторов, содержащих от 50 млн. вещественных значений (предварительно заполнить векторы случайными значениями, предусмотреть выделение и освобождение областей памяти для векторов с помощью функций стандартной библиотеки С++). Вычислить и 
вывести на экран время выполнения сложения, с использованием функций 
библиотеки OpenMP. Вывести на экран размер и любой элемент результирующего вектора. 
2. Выполнить задание 1, используя директиву Parallel с опцией Shared 
(для векторов). Сравнить полученное время с временем в задаче 1, сделать 
выводы.
3. Определите, какое максимальное количество нитей позволяет породить для выполнения параллельных областей программы ваша система.
4. При помощи трёх уровней вложенных параллельных областей породите 8 нитей (на каждом уровне параллельную область должны исполнять 
2 нити). Посмотрите, как будет исполняться программа, если запретить вложенные параллельные области.
5. Написать пример реализации директивы For с опцией nowait, проиллюстрировать работу (печатать номер текущей итерации и номер потока, 
выполнившего свою часть цикла).
6. Написать пример реализации директивы For с опцией collapse, проиллюстрировать работу (печатать номера текущих итераций и номер потока, их выполнившего).
7. Написать пример реализации директивы For с опцией reduction, в 
котором определенным образом накапливаются значения из разных итераций цикла. Проиллюстрировать работу.
8. Написать пример реализации директивы Sections и директивы 
Section (совместно) для 4-х задач, в которых все задачи могут работать параллельно, но 2 и 3 задачи – только вместе, друг за другом.

_____________

## PyOpenCl

*семинары 03.06.2024*

9. Создать программу для решения простых дифференциальных уравнений с помощью функции ядра, используйте метод Эйлера или метод 
Рунге-Кутты .
10. Создать программу для приближенного вычисления числа Пи с помощью функции ядра, используйте метод Монте-Карло.
11. Реализовать с использованием функций ядра в PyOpenCL фракталы:
- множество Бернса-Шиппена
12. множество Ньютона
13. множество Лямберта
14. множество Кантора


____________

# MPI

*семинары 08.06.2024*

15. Коллективное взаимодействие через широковещательный обмен -
функция Bcast, при помощи функции разброса scatter, при помощи функции
получения gather
Bcast
Выполнить задание по вариантам:
- Вариант 1: Напишите программу на Python, используя модуль mpi4py, 
которая создает словарь данных на процессе с рангом 0 и затем распространяет эти данные на все остальные процессы с помощью функции comm.bcast. Словарь должен содержать два ключа: ‘key1’ и ‘key2’. 
‘key1’ должен быть связан со списком, содержащим три элемента: целое 
число, вещественное число и комплексное число. ‘key2’ должен быть связан 
с кортежем, содержащим две строки. После получения данных каждый процесс должен выводить свой ранг и полученные данные.
16. Вариант 2: Напишите программу на Python, используя модуль mpi4py, 
которая запрашивает у пользователя ввод серии целых чисел на процессе с 
рангом 0, а затем распространяет этот ввод на все остальные процессы с помощью функции comm.bcast. Ввод пользователя должен быть целым числом. После получения ввода каждый процесс должен выводить свой ранг и 
полученный ввод. Убедитесь, что запрос на ввод числа отображается на русском языке.

### Scatter

*семинары 08.06.2024*

17. Вариант 1: Использование `comm.scatter` для распределения данных
Напишите программу на Python, используя модуль `mpi4py`, которая 
создает список чисел на процессе с рангом 0 и затем распространяет эти 
числа на все остальные процессы с помощью функции `comm.scatter`. Каждый процесс должен получить одно число из списка. После получения числа 
каждый процесс должен выводить свой ранг и полученное число.

18. Вариант 2: Использование `comm.scatter` для распределения входных 
данных
Напишите программу на Python, используя модуль `mpi4py`, которая 
запрашивает у пользователя ввод серии целых чисел на процессе с рангом 
0, а затем распространяет эти числа на все остальные процессы с помощью 
функции `comm.scatter`. Пользователь должен ввести числа через пробел. 
После получения числа каждый процесс должен выводить свой ранг и полученное число.
## Gather

*семинары 08.06.2024*

19. Вариант 1: Использование `comm.scatter` и `comm.gather` для обработки данных
Напишите программу на Python, используя модуль `mpi4py`, которая 
создает список чисел на процессе с рангом 0, распространяет эти числа на 
все процессы с помощью функции `comm.scatter`, затем каждый процесс 
увеличивает свое число на 1 и собирает обновленные числа обратно на процессе с рангом 0 с помощью функции `comm.gather`. На процессе с рангом 0 должен быть выведен исходный список чисел и обновленный список чисел.

20. Вариант 2: Использование `comm.scatter` и `comm.gather` для обработки входных данных
Напишите программу на Python, используя модуль `mpi4py`, которая 
запрашивает у пользователя ввод серии целых чисел на процессе с рангом 
0, распространяет эти числа на все процессы с помощью функции 
`comm.scatter`, затем каждый процесс увеличивает свое число на 1 и собирает обновленные числа обратно на процессе с рангом 0 с помощью функции `comm.gather`. На процессе с рангом 0 должны быть выведены исходная 
серия чисел и обновленная серия чисел.

## 2. Совместное взаимодействие с помощью функции Alltoall, операция свёртки reduce
AlltoAll

*семинары 08.06.2024*


21. Вариант 1: Напишите программу, которая использует функцию 
alltoall, чтобы распределить данные между всеми процессами в коммуникаторе. Каждый процесс должен создать массив случайных чисел и отправить 
его всем другим процессам. Затем каждый процесс должен обработать полученные данные (например, вычислить среднее значение), отсортировать 
полученные данные и отправить результаты обратно всем процессам с помощью alltoall. В конце каждый процесс должен вывести исходные и полученные данные, а также результаты обработки;

23. Вариант 2: Напишите программу, которая использует метод Монте-Карло для приближенного вычисления числа Пи. Каждый процесс должен 
генерировать случайные точки в квадрате и определять, находятся ли они 
внутри круга. Затем все процессы должны использовать alltoall, чтобы обменяться своими результатами и вычислить общее количество точек внутри 
круга. Используйте это число для вычисления приближенного значения Пи. 
В конце каждый процесс должен вывести свои исходные данные, полученные данные и приближенное значение Пи.

## Reduce

*семинары 08.06.2024*

23. Вариант 1: Напишите программу, которая использует функцию 
reduce, чтобы найти минимальное значение среди всех значений, сгенерированных всеми процессами. Каждый процесс должен сгенерировать случайное число. Затем используйте reduce с операцией MPI.MIN, чтобы найти минимальное значение. В конце процесс с рангом 0 должен вывести 
минимальное значение;
24. Вариант 2: Напишите программу, которая использует функцию 
reduce, чтобы найти максимальное значение среди всех значений, сгенерированных всеми процессами. Каждый процесс должен сгенерировать случайное число. Затем используйте reduce с операцией MPI.MAX, чтобы 
найти максимальное значение. В конце процесс с рангом 0 должен вывести 
максимальное значение.

## 3. Декартова топология, бесконечная сетка

*семинары 08.06.2024*

Декартова топология 

25. Вариант 1: Реализуйте на MPI разбиение процессов приложения на 
две группы, в одной из которых осуществляется обмен по кольцевой топологии, а в другой – коммуникации по схеме «мастер – рабочие» (с использованием любых изученных функций).
26. Вариант 2: Реализуйте на MPI разбиение процессов приложения на 
две группы, чтобы в первой группе осуществлялся обмен по кольцевой топологии при помощи сдвига в одномерной декартовой топологии, а в другой – коммуникации по схеме «мастер – рабочие», реализованной при помощи топологии графа.

## Бесконечная сетка

*семинары 08.06.2024*

27. Вариант 1: Реализовать алгоритм обхода в ширину (BFS) на бесконечной сетке с периодическими граничными условиями (также известными как 
тороидальные границы). Программа должна начинать обход из заданной 
начальной точки и продолжать до тех пор, пока не будет достигнута заданная глубина; программа должна корректно обрабатывать переходы через 
границы сетки и быть способна работать с произвольным количеством процессов.
Программа должна выводить состояние сетки после завершения BFS. 
Каждый процесс должен выводить свою собственную копию сетки, чтобы 
можно было видеть, как состояние сетки синхронизируется между процессами.
28. Вариант 2: Реализовать алгоритм распространения волны на бесконечной сетке с периодическими граничными условиями (также известными 
как тороидальные границы). Программа должна моделировать распространение волны от заданной начальной точки на заданное количество шагов; 
программа должна корректно обрабатывать переходы через границы сетки 
и быть способна работать с произвольным количеством процессов и корректно обрабатывать переходы через границы сетки.
Программа должна выводить состояние сетки после завершения распространения волны. Каждый процесс должен выводить свою собственную 
копию сетки, чтобы можно было видеть, как состояние сетки синхронизируется между процессами




## Пример экзаменационного билета 
- Задание 1. (10 баллов) Межпроцессное взаимодействие с помощью интерфейса MPI.

- Задание 2. (20 баллов)MIMD архитектуры высокопроизводительных вычислений. Реализация MIMD вычислений с помощью OpenMP.

- Задание 3. (30 баллов) С использованием инструментария MPI разработайте программу, реализующую алгоритм поиска в глубину в неориентированном графе.
