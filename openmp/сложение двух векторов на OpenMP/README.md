Выполнить сложение двух векторов, содержащих от 50 млн. веще-
ственных значений (предварительно заполнить векторы случайными значе-
ниями, предусмотреть выделение и освобождение областей памяти для век-
торов с помощью функций стандартной библиотеки С++). Вычислить и
вывести на экран время выполнения сложения, с использованием функций
библиотеки OpenMP. Вывести на экран размер и любой элемент результи-
рующего вектора.


Для выполнения этой задачи на языке C++ с использованием библиотеки OpenMP, можно следовать следующим шагам:

1. Создать два вектора, заполненные случайными вещественными значениями.
2. Выполнить их сложение параллельно.
3. Измерить время выполнения операции сложения.
4. Вывести на экран время выполнения, размер результирующего вектора и любой элемент этого вектора.

Ниже представлен пример кода, который выполняет эту задачу:

```cpp
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <omp.h>

// Функция для заполнения вектора случайными вещественными значениями
void fillVector(std::vector<double> &vec) {
    #pragma omp parallel for
    for (size_t i = 0; i < vec.size(); ++i) {
        vec[i] = static_cast<double>(rand()) / RAND_MAX;
    }
}

int main() {
    // Размер векторов
    const size_t N = 50000000;

    // Выделение памяти для векторов
    std::vector<double> vecA(N);
    std::vector<double> vecB(N);
    std::vector<double> vecC(N);

    // Заполнение векторов случайными значениями
    srand(static_cast<unsigned>(time(0)));
    fillVector(vecA);
    fillVector(vecB);

    // Начало измерения времени
    double startTime = omp_get_wtime();

    // Сложение векторов с использованием OpenMP
    #pragma omp parallel for
    for (size_t i = 0; i < N; ++i) {
        vecC[i] = vecA[i] + vecB[i];
    }

    // Конец измерения времени
    double endTime = omp_get_wtime();

    // Вывод результатов
    std::cout << "Time taken for vector addition: " << (endTime - startTime) << " seconds." << std::endl;
    std::cout << "Size of resulting vector: " << vecC.size() << std::endl;
    std::cout << "Example element from resulting vector: " << vecC[N / 2] << std::endl;

    return 0;
}
```

### Пояснение кода:

1. **Заполнение векторов случайными значениями**:
   - Функция `fillVector` заполняет вектор случайными значениями в диапазоне от 0 до 1.
   - Используется директива `#pragma omp parallel for` для параллельного заполнения вектора.

2. **Измерение времени выполнения**:
   - Время начала выполнения операции складывания векторов сохраняется в переменную `startTime` с помощью функции `omp_get_wtime`.
   - Время окончания выполнения сохраняется в переменную `endTime`.

3. **Сложение векторов**:
   - Директива `#pragma omp parallel for` позволяет выполнять сложение элементов векторов параллельно.

4. **Вывод результатов**:
   - Время выполнения операции сложения выводится в секундах.
   - Размер результирующего вектора и пример одного из его элементов также выводятся на экран.

Для компиляции и запуска программы необходимо использовать компилятор, поддерживающий OpenMP, например, `g++`. Команда для компиляции может выглядеть следующим образом:

```sh
g++ -fopenmp -o vector_addition vector_addition.cpp
```

А затем запуск программы:

```sh
./vector_addition
```

Этот код эффективно выполняет сложение двух больших векторов с использованием параллельных вычислений, что значительно сокращает время выполнения операции.

